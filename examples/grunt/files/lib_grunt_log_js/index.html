<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title></title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet">
  <link href="../../assets/css/vendor/font-awesome-ie7.css" rel="stylesheet">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet">
  <link href="../../assets/css/plato.css" rel="stylesheet">
  <link href="../../assets/css/plato-file.css" rel="stylesheet">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="http://github.com/jsoverson/plato">Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>lib/grunt/log.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"></i></a></h2>
      <p class="stat">71.76</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC"></i></h2>
      <p class="stat">343</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty"></i></a></h2>
      <p class="stat">57.01</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs"></i></a></h2>
      <p class="stat">2.87</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">/*
 * grunt
 * http://gruntjs.com/
 *
 * Copyright (c) 2013 &quot;Cowboy&quot; Ben Alman
 * Licensed under the MIT license.
 * https://github.com/gruntjs/grunt/blob/master/LICENSE-MIT
 */

&#039;use strict&#039;;

var grunt = require(&#039;../grunt&#039;);

// Nodejs libs.
var util = require(&#039;util&#039;);

// The module to be exported.
var log = module.exports = {};

// External lib. Requiring this here modifies the String prototype!
var colors = require(&#039;colors&#039;);

// Disable colors if --no-colors was passed.
log.initColors = function() {
  var util = grunt.util;
  if (grunt.option(&#039;no-color&#039;)) {
    // String color getters should just return the string.
    colors.mode = &#039;none&#039;;
    // Strip colors from strings passed to console.log.
    util.hooker.hook(console, &#039;log&#039;, function() {
      var args = util.toArray(arguments);
      return util.hooker.filter(this, args.map(function(arg) {
        return util.kindOf(arg) === &#039;string&#039; ? colors.stripColors(arg) : arg;
      }));
    });
  }
};

// Temporarily suppress output.
var suppressOutput;

// Allow external muting of output.
log.muted = false;

// True once anything has actually been logged.
var hasLogged;

// Parse certain markup in strings to be logged.
function markup(str) {
  str = str || &#039;&#039;;
  // Make _foo_ underline.
  str = str.replace(/(\s|^)_(\S|\S[\s\S]+?\S)_(?=[\s,.!?]|$)/g, &#039;$1&#039; + &#039;$2&#039;.underline);
  // Make *foo* bold.
  str = str.replace(/(\s|^)\*(\S|\S[\s\S]+?\S)\*(?=[\s,.!?]|$)/g, &#039;$1&#039; + &#039;$2&#039;.bold);
  return str;
}

// Similar to util.format in the standard library, however it&#039;ll always
// cast the first argument to a string and treat it as the format string.
function format(args) {
  // Args is a argument array so copy it in order to avoid wonky behavior.
  args = [].slice.call(args, 0);
  if (args.length &gt; 0) {
    args[0] = String(args[0]);
  }
  return util.format.apply(util, args);
}

function write(msg) {
  msg = msg || &#039;&#039;;
  // Actually write output.
  if (!log.muted &amp;&amp; !suppressOutput) {
    hasLogged = true;
    // Users should probably use the colors-provided methods, but if they
    // don&#039;t, this should strip extraneous color codes.
    if (grunt.option(&#039;no-color&#039;)) { msg = colors.stripColors(msg); }
    // Actually write to stdout.
    process.stdout.write(markup(msg));
  }
}

function writeln(msg) {
  // Write blank line if no msg is passed in.
  msg = msg || &#039;&#039;;
  write(msg + &#039;\n&#039;);
}

// Write output.
log.write = function() {
  write(format(arguments));
  return log;
};

// Write a line of output.
log.writeln = function() {
  writeln(format(arguments));
  return log;
};

log.warn = function() {
  var msg = format(arguments);
  if (arguments.length &gt; 0) {
    writeln(&#039;&gt;&gt; &#039;.red + grunt.util._.trim(msg).replace(/\n/g, &#039;\n&gt;&gt; &#039;.red));
  } else {
    writeln(&#039;ERROR&#039;.red);
  }
  return log;
};
log.error = function() {
  grunt.fail.errorcount++;
  log.warn.apply(log, arguments);
  return log;
};
log.ok = function() {
  var msg = format(arguments);
  if (arguments.length &gt; 0) {
    writeln(&#039;&gt;&gt; &#039;.green + grunt.util._.trim(msg).replace(/\n/g, &#039;\n&gt;&gt; &#039;.green));
  } else {
    writeln(&#039;OK&#039;.green);
  }
  return log;
};
log.errorlns = function() {
  var msg = format(arguments);
  log.error(log.wraptext(77, msg));
  return log;
};
log.oklns = function() {
  var msg = format(arguments);
  log.ok(log.wraptext(77, msg));
  return log;
};
log.success = function() {
  var msg = format(arguments);
  writeln(msg.green);
  return log;
};
log.fail = function() {
  var msg = format(arguments);
  writeln(msg.red);
  return log;
};
log.header = function() {
  var msg = format(arguments);
  // Skip line before header, but not if header is the very first line output.
  if (hasLogged) { writeln(); }
  writeln(msg.underline);
  return log;
};
log.subhead = function() {
  var msg = format(arguments);
  // Skip line before subhead, but not if subhead is the very first line output.
  if (hasLogged) { writeln(); }
  writeln(msg.bold);
  return log;
};
// For debugging.
log.debug = function() {
  var msg = format(arguments);
  if (grunt.option(&#039;debug&#039;)) {
    writeln(&#039;[D] &#039; + msg.magenta);
  }
  return log;
};

// Write a line of a table.
log.writetableln = function(widths, texts) {
  writeln(log.table(widths, texts));
  return log;
};

// Wrap a long line of text to 80 columns.
log.writelns = function() {
  var msg = format(arguments);
  writeln(log.wraptext(80, msg));
  return log;
};

// Display flags in verbose mode.
log.writeflags = function(obj, prefix) {
  var wordlist;
  if (Array.isArray(obj)) {
    wordlist = log.wordlist(obj);
  } else if (typeof obj === &#039;object&#039; &amp;&amp; obj) {
    wordlist = log.wordlist(Object.keys(obj).map(function(key) {
      var val = obj[key];
      return key + (val === true ? &#039;&#039; : &#039;=&#039; + JSON.stringify(val));
    }));
  }
  writeln((prefix || &#039;Flags&#039;) + &#039;: &#039; + (wordlist || &#039;(none)&#039;.cyan));
  return log;
};

// Create explicit &quot;verbose&quot; and &quot;notverbose&quot; functions, one for each already-
// defined log function, that do the same thing but ONLY if -v or --verbose is
// specified (or not specified).
log.verbose = {};
log.notverbose = {};

// Iterate over all exported functions.
Object.keys(log).filter(function(key) {
  return typeof log[key] === &#039;function&#039;;
}).forEach(function(key) {
  // Like any other log function, but suppresses output if the &quot;verbose&quot; option
  // IS NOT set.
  log.verbose[key] = function() {
    suppressOutput = !grunt.option(&#039;verbose&#039;);
    log[key].apply(log, arguments);
    suppressOutput = false;
    return log.verbose;
  };
  // Like any other log function, but suppresses output if the &quot;verbose&quot; option
  // IS set.
  log.notverbose[key] = function() {
    suppressOutput = grunt.option(&#039;verbose&#039;);
    log[key].apply(log, arguments);
    suppressOutput = false;
    return log.notverbose;
  };
});

// A way to switch between verbose and notverbose modes. For example, this will
// write &#039;foo&#039; if verbose logging is enabled, otherwise write &#039;bar&#039;:
// verbose.write(&#039;foo&#039;).or.write(&#039;bar&#039;);
log.verbose.or = log.notverbose;
log.notverbose.or = log.verbose;

// Static methods.

// Pretty-format a word list.
log.wordlist = function(arr, options) {
  options = grunt.util._.defaults(options || {}, {
    separator: &#039;, &#039;,
    color: &#039;cyan&#039;
  });
  return arr.map(function(item) {
    return options.color ? String(item)[options.color] : item;
  }).join(options.separator);
};

// Return a string, uncolored (suitable for testing .length, etc).
log.uncolor = function(str) {
  return str.replace(/\x1B\[\d+m/g, &#039;&#039;);
};

// Word-wrap text to a given width, permitting ANSI color codes.
log.wraptext = function(width, text) {
  // notes to self:
  // grab 1st character or ansi code from string
  // if ansi code, add to array and save for later, strip from front of string
  // if character, add to array and increment counter, strip from front of string
  // if width + 1 is reached and current character isn&#039;t space:
  //  slice off everything after last space in array and prepend it to string
  //  etc

  // This result array will be joined on \n.
  var result = [];
  var matches, color, tmp;
  var captured = [];
  var charlen = 0;

  while (matches = text.match(/(?:(\x1B\[\d+m)|\n|(.))([\s\S]*)/)) {
    // Updated text to be everything not matched.
    text = matches[3];

    // Matched a color code?
    if (matches[1]) {
      // Save last captured color code for later use.
      color = matches[1];
      // Capture color code.
      captured.push(matches[1]);
      continue;

    // Matched a non-newline character?
    } else if (matches[2]) {
      // If this is the first character and a previous color code was set, push
      // that onto the captured array first.
      if (charlen === 0 &amp;&amp; color) { captured.push(color); }
      // Push the matched character.
      captured.push(matches[2]);
      // Increment the current charlen.
      charlen++;
      // If not yet at the width limit or a space was matched, continue.
      if (charlen &lt;= width || matches[2] === &#039; &#039;) { continue; }
      // The current charlen exceeds the width and a space wasn&#039;t matched.
      // &quot;Roll everything back&quot; until the last space character.
      tmp = captured.lastIndexOf(&#039; &#039;);
      text = captured.slice(tmp === -1 ? tmp : tmp + 1).join(&#039;&#039;) + text;
      captured = captured.slice(0, tmp);
    }

    // The limit has been reached. Push captured string onto result array.
    result.push(captured.join(&#039;&#039;));

    // Reset captured array and charlen.
    captured = [];
    charlen = 0;
  }

  result.push(captured.join(&#039;&#039;));
  return result.join(&#039;\n&#039;);
};

// todo: write unit tests
//
// function logs(text) {
//   [4, 6, 10, 15, 20, 25, 30, 40].forEach(function(n) {
//     log(n, text);
//   });
// }
//
// function log(n, text) {
//   console.log(Array(n + 1).join(&#039;-&#039;));
//   console.log(wrap(n, text));
// }
//
// var text = &#039;this is &#039;.red + &#039;a simple&#039;.yellow.inverse + &#039; test of&#039;.green + &#039; &#039; + &#039;some wrapped&#039;.blue + &#039; text over &#039;.inverse.magenta + &#039;many lines&#039;.red;
// logs(text);
//
// var text = &#039;foolish &#039;.red.inverse + &#039;monkeys&#039;.yellow + &#039; eating&#039;.green + &#039; &#039; + &#039;delicious&#039;.inverse.blue + &#039; bananas &#039;.magenta + &#039;forever&#039;.red;
// logs(text);
//
// var text = &#039;foolish monkeys eating delicious bananas forever&#039;.rainbow;
// logs(text);

// Format output into columns, wrapping words as-necessary.
log.table = function(widths, texts) {
  var rows = [];
  widths.forEach(function(width, i) {
    var lines = log.wraptext(width, texts[i]).split(&#039;\n&#039;);
    lines.forEach(function(line, j) {
      var row = rows[j];
      if (!row) { row = rows[j] = []; }
      row[i] = line;
    });
  });

  var lines = [];
  rows.forEach(function(row) {
    var txt = &#039;&#039;;
    var column;
    for (var i = 0; i &lt; row.length; i++) {
      column = row[i] || &#039;&#039;;
      txt += column;
      var diff = widths[i] - log.uncolor(column).length;
      if (diff &gt; 0) { txt += grunt.util.repeat(diff, &#039; &#039;); }
    }
    lines.push(txt);
  });

  return lines.join(&#039;\n&#039;);
};</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
