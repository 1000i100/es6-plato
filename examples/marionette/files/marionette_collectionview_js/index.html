<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - marionette.collectionview.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet">
  <link href="../../assets/css/plato.css" rel="stylesheet">
  <link href="../../assets/css/plato-file.css" rel="stylesheet">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="http://github.com/es-analysis/plato">Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>marionette.collectionview.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">74.05</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">468</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">63.27</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">3.22</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">/* jshint maxstatements: 14 */

// Collection View
// ---------------

// A view that iterates over a Backbone.Collection
// and renders an individual child view for each model.
Marionette.CollectionView = Marionette.View.extend({

  // used as the prefix for child view events
  // that are forwarded through the collectionview
  childViewEventPrefix: &#039;childview&#039;,

  // constructor
  // option to pass `{sort: false}` to prevent the `CollectionView` from
  // maintaining the sorted order of the collection.
  // This will fallback onto appending childView&#039;s to the end.
  constructor: function(options){
    var initOptions = options || {};
    this.sort = _.isUndefined(initOptions.sort) ? true : initOptions.sort;

    this.once(&#039;render&#039;, this._initialEvents);
    this._initChildViewStorage();

    Marionette.View.apply(this, arguments);

    this.initRenderBuffer();
  },

  // Instead of inserting elements one by one into the page,
  // it&#039;s much more performant to insert elements into a document
  // fragment and then insert that document fragment into the page
  initRenderBuffer: function() {
    this.elBuffer = document.createDocumentFragment();
    this._bufferedChildren = [];
  },

  startBuffering: function() {
    this.initRenderBuffer();
    this.isBuffering = true;
  },

  endBuffering: function() {
    this.isBuffering = false;
    this._triggerBeforeShowBufferedChildren();
    this.attachBuffer(this, this.elBuffer);
    this._triggerShowBufferedChildren();
    this.initRenderBuffer();
  },

  _triggerBeforeShowBufferedChildren: function() {
    if (this._isShown) {
      _.each(this._bufferedChildren, _.partial(this._triggerMethodOnChild, &#039;before:show&#039;));
    }
  },

  _triggerShowBufferedChildren: function() {
    if (this._isShown) {
      _.each(this._bufferedChildren, _.partial(this._triggerMethodOnChild, &#039;show&#039;));

      this._bufferedChildren = [];
    }
  },

  // Internal method for _.each loops to call `Marionette.triggerMethodOn` on
  // a child view
  _triggerMethodOnChild: function(event, childView) {
    Marionette.triggerMethodOn(childView, event);
  },

  // Configured the initial events that the collection view
  // binds to.
  _initialEvents: function() {
    if (this.collection) {
      this.listenTo(this.collection, &#039;add&#039;, this._onCollectionAdd);
      this.listenTo(this.collection, &#039;remove&#039;, this._onCollectionRemove);
      this.listenTo(this.collection, &#039;reset&#039;, this.render);

      if (this.sort) {
        this.listenTo(this.collection, &#039;sort&#039;, this._sortViews);
      }
    }
  },

  // Handle a child added to the collection
  _onCollectionAdd: function(child) {
    this.destroyEmptyView();
    var ChildView = this.getChildView(child);
    var index = this.collection.indexOf(child);
    this.addChild(child, ChildView, index);
  },

  // get the child view by model it holds, and remove it
  _onCollectionRemove: function(model) {
    var view = this.children.findByModel(model);
    this.removeChildView(view);
    this.checkEmpty();
  },

  // Override from `Marionette.View` to trigger show on child views
  onShowCalled: function() {
    this.children.each(_.partial(this._triggerMethodOnChild, &#039;show&#039;));
  },

  // Render children views. Override this method to
  // provide your own implementation of a render function for
  // the collection view.
  render: function() {
    this._ensureViewIsIntact();
    this.triggerMethod(&#039;before:render&#039;, this);
    this._renderChildren();
    this.triggerMethod(&#039;render&#039;, this);
    return this;
  },

  // Render view after sorting. Override this method to
  // change how the view renders after a `sort` on the collection.
  // An example of this would be to only `renderChildren` in a `CompositeView`
  // rather than the full view.
  resortView: function() {
    this.render();
  },

  // Internal method. This checks for any changes in the order of the collection.
  // If the index of any view doesn&#039;t match, it will render.
  _sortViews: function() {
    // check for any changes in sort order of views
    var orderChanged = this.collection.find(function(item, index){
      var view = this.children.findByModel(item);
      return !view || view._index !== index;
    }, this);

    if (orderChanged) {
      this.resortView();
    }
  },

  // Internal method. Separated so that CompositeView can have
  // more control over events being triggered, around the rendering
  // process
  _renderChildren: function() {
    this.destroyEmptyView();
    this.destroyChildren();

    if (this.isEmpty(this.collection)) {
      this.showEmptyView();
    } else {
      this.triggerMethod(&#039;before:render:collection&#039;, this);
      this.startBuffering();
      this.showCollection();
      this.endBuffering();
      this.triggerMethod(&#039;render:collection&#039;, this);
    }
  },

  // Internal method to loop through collection and show each child view.
  showCollection: function() {
    var ChildView;
    this.collection.each(function(child, index) {
      ChildView = this.getChildView(child);
      this.addChild(child, ChildView, index);
    }, this);
  },

  // Internal method to show an empty view in place of
  // a collection of child views, when the collection is empty
  showEmptyView: function() {
    var EmptyView = this.getEmptyView();

    if (EmptyView &amp;&amp; !this._showingEmptyView) {
      this.triggerMethod(&#039;before:render:empty&#039;);

      this._showingEmptyView = true;
      var model = new Backbone.Model();
      this.addEmptyView(model, EmptyView);

      this.triggerMethod(&#039;render:empty&#039;);
    }
  },

  // Internal method to destroy an existing emptyView instance
  // if one exists. Called when a collection view has been
  // rendered empty, and then a child is added to the collection.
  destroyEmptyView: function() {
    if (this._showingEmptyView) {
      this.triggerMethod(&#039;before:remove:empty&#039;);

      this.destroyChildren();
      delete this._showingEmptyView;

      this.triggerMethod(&#039;remove:empty&#039;);
    }
  },

  // Retrieve the empty view class
  getEmptyView: function() {
    return this.getOption(&#039;emptyView&#039;);
  },

  // Render and show the emptyView. Similar to addChild method
  // but &quot;child:added&quot; events are not fired, and the event from
  // emptyView are not forwarded
  addEmptyView: function(child, EmptyView) {

    // get the emptyViewOptions, falling back to childViewOptions
    var emptyViewOptions = this.getOption(&#039;emptyViewOptions&#039;) ||
                          this.getOption(&#039;childViewOptions&#039;);

    if (_.isFunction(emptyViewOptions)){
      emptyViewOptions = emptyViewOptions.call(this);
    }

    // build the empty view
    var view = this.buildChildView(child, EmptyView, emptyViewOptions);

    // Proxy emptyView events
    this.proxyChildEvents(view);

    // trigger the &#039;before:show&#039; event on `view` if the collection view
    // has already been shown
    if (this._isShown) {
      Marionette.triggerMethodOn(view, &#039;before:show&#039;);
    }

    // Store the `emptyView` like a `childView` so we can properly
    // remove and/or close it later
    this.children.add(view);

    // Render it and show it
    this.renderChildView(view, -1);

    // call the &#039;show&#039; method if the collection view
    // has already been shown
    if (this._isShown) {
      Marionette.triggerMethodOn(view, &#039;show&#039;);
    }
  },

  // Retrieve the `childView` class, either from `this.options.childView`
  // or from the `childView` in the object definition. The &quot;options&quot;
  // takes precedence.
  // This method receives the model that will be passed to the instance
  // created from this `childView`. Overriding methods may use the child
  // to determine what `childView` class to return.
  getChildView: function(child) {
    var childView = this.getOption(&#039;childView&#039;);

    if (!childView) {
      throw new Marionette.Error({
        name: &#039;NoChildViewError&#039;,
        message: &#039;A &quot;childView&quot; must be specified&#039;
      });
    }

    return childView;
  },

  // Render the child&#039;s view and add it to the
  // HTML for the collection view at a given index.
  // This will also update the indices of later views in the collection
  // in order to keep the children in sync with the collection.
  addChild: function(child, ChildView, index) {
    var childViewOptions = this.getOption(&#039;childViewOptions&#039;);
    if (_.isFunction(childViewOptions)) {
      childViewOptions = childViewOptions.call(this, child, index);
    }

    var view = this.buildChildView(child, ChildView, childViewOptions);

    // increment indices of views after this one
    this._updateIndices(view, true, index);

    this._addChildView(view, index);

    return view;
  },

  // Internal method. This decrements or increments the indices of views after the
  // added/removed view to keep in sync with the collection.
  _updateIndices: function(view, increment, index) {
    if (!this.sort) {
      return;
    }

    if (increment) {
      // assign the index to the view
      view._index = index;

      // increment the index of views after this one
      this.children.each(function (laterView) {
        if (laterView._index &gt;= view._index) {
          laterView._index++;
        }
      });
    }
    else {
      // decrement the index of views after this one
      this.children.each(function (laterView) {
        if (laterView._index &gt;= view._index) {
          laterView._index--;
        }
      });
    }
  },


  // Internal Method. Add the view to children and render it at
  // the given index.
  _addChildView: function(view, index) {
    // set up the child view event forwarding
    this.proxyChildEvents(view);

    this.triggerMethod(&#039;before:add:child&#039;, view);

    // Store the child view itself so we can properly
    // remove and/or destroy it later
    this.children.add(view);
    this.renderChildView(view, index);

    if (this._isShown &amp;&amp; !this.isBuffering) {
      Marionette.triggerMethodOn(view, &#039;show&#039;);
    }

    this.triggerMethod(&#039;add:child&#039;, view);
  },

  // render the child view
  renderChildView: function(view, index) {
    view.render();
    this.attachHtml(this, view, index);
    return view;
  },

  // Build a `childView` for a model in the collection.
  buildChildView: function(child, ChildViewClass, childViewOptions) {
    var options = _.extend({model: child}, childViewOptions);
    return new ChildViewClass(options);
  },

  // Remove the child view and destroy it.
  // This function also updates the indices of
  // later views in the collection in order to keep
  // the children in sync with the collection.
  removeChildView: function(view) {

    if (view) {
      this.triggerMethod(&#039;before:remove:child&#039;, view);
      // call &#039;destroy&#039; or &#039;remove&#039;, depending on which is found
      if (view.destroy) { view.destroy(); }
      else if (view.remove) { view.remove(); }

      this.stopListening(view);
      this.children.remove(view);
      this.triggerMethod(&#039;remove:child&#039;, view);

      // decrement the index of views after this one
      this._updateIndices(view, false);
    }

    return view;
  },

  // check if the collection is empty
  isEmpty: function() {
    return !this.collection || this.collection.length === 0;
  },

  // If empty, show the empty view
  checkEmpty: function() {
    if (this.isEmpty(this.collection)) {
      this.showEmptyView();
    }
  },

  // You might need to override this if you&#039;ve overridden attachHtml
  attachBuffer: function(collectionView, buffer) {
    collectionView.$el.append(buffer);
  },

  // Append the HTML to the collection&#039;s `el`.
  // Override this method to do something other
  // than `.append`.
  attachHtml: function(collectionView, childView, index) {
    if (collectionView.isBuffering) {
      // buffering happens on reset events and initial renders
      // in order to reduce the number of inserts into the
      // document, which are expensive.
      collectionView.elBuffer.appendChild(childView.el);
      collectionView._bufferedChildren.push(childView);
    }
    else {
      // If we&#039;ve already rendered the main collection, append
      // the new child into the correct order if we need to. Otherwise
      // append to the end.
      if (!collectionView._insertBefore(childView, index)){
        collectionView._insertAfter(childView);
      }
    }
  },

  // Internal method. Check whether we need to insert the view into
  // the correct position.
  _insertBefore: function(childView, index) {
    var currentView;
    var findPosition = this.sort &amp;&amp; (index &lt; this.children.length - 1);
    if (findPosition) {
      // Find the view after this one
      currentView = this.children.find(function (view) {
        return view._index === index + 1;
      });
    }

    if (currentView) {
      currentView.$el.before(childView.el);
      return true;
    }

    return false;
  },

  // Internal method. Append a view to the end of the $el
  _insertAfter: function(childView) {
    this.$el.append(childView.el);
  },

  // Internal method to set up the `children` object for
  // storing all of the child views
  _initChildViewStorage: function() {
    this.children = new Backbone.ChildViewContainer();
  },

  // Handle cleanup and other destroying needs for the collection of views
  destroy: function() {
    if (this.isDestroyed) { return; }

    this.triggerMethod(&#039;before:destroy:collection&#039;);
    this.destroyChildren();
    this.triggerMethod(&#039;destroy:collection&#039;);

    return Marionette.View.prototype.destroy.apply(this, arguments);
  },

  // Destroy the child views that this collection view
  // is holding on to, if any
  destroyChildren: function() {
    var childViews = this.children.map(_.identity);
    this.children.each(this.removeChildView, this);
    this.checkEmpty();
    return childViews;
  },

  // Set up the child view event forwarding. Uses a &quot;childview:&quot;
  // prefix in front of all forwarded events.
  proxyChildEvents: function(view) {
    var prefix = this.getOption(&#039;childViewEventPrefix&#039;);

    // Forward all child view events through the parent,
    // prepending &quot;childview:&quot; to the event name
    this.listenTo(view, &#039;all&#039;, function() {
      var args = slice.call(arguments);
      var rootEvent = args[0];
      var childEvents = this.normalizeMethods(_.result(this, &#039;childEvents&#039;));

      args[0] = prefix + &#039;:&#039; + rootEvent;
      args.splice(1, 0, view);

      // call collectionView childEvent if defined
      if (typeof childEvents !== &#039;undefined&#039; &amp;&amp; _.isFunction(childEvents[rootEvent])) {
        childEvents[rootEvent].apply(this, args.slice(1));
      }

      this.triggerMethod.apply(this, args);
    }, this);
  }
});</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
